"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.httpRequest = void 0;
const axios_1 = __importDefault(require("axios"));
const https_1 = __importDefault(require("https"));
const fs_1 = __importDefault(require("fs"));
function buildAgent(options) {
    if (!options.certificate)
        return undefined;
    try {
        if (!options.cert_base64) {
            if (options.pemKey) {
                return new https_1.default.Agent({
                    cert: fs_1.default.readFileSync(options.certificate),
                    key: fs_1.default.readFileSync(options.pemKey),
                    passphrase: '',
                });
            }
            else {
                return new https_1.default.Agent({
                    pfx: fs_1.default.readFileSync(options.certificate),
                    passphrase: '',
                });
            }
        }
        else {
            if (options.pemKey) {
                return new https_1.default.Agent({
                    cert: Buffer.from(options.certificate, 'base64'),
                    key: Buffer.from(options.pemKey, 'base64'),
                    passphrase: '',
                });
            }
            else {
                return new https_1.default.Agent({
                    pfx: Buffer.from(options.certificate, 'base64'),
                    passphrase: '',
                });
            }
        }
    }
    catch (error) {
        throw new Error('Erro ao ler o certificado ou chave: ' + error.message);
    }
}
function buildRoute(route, routeParams) {
    if (!routeParams)
        return route;
    return route.replace(/:([a-zA-Z0-9_]+)/g, (_, key) => {
        if (routeParams[key] === undefined)
            throw new Error(`Parâmetro de rota ausente: ${key}`);
        return encodeURIComponent(String(routeParams[key]));
    });
}
async function httpRequest(options) {
    const { baseUrl, endpoint, body, params, headers = {}, routeParams, certificate, pemKey, cert_base64, partner_token, validateMtls, authorization, idempotencyKey, } = options;
    const url = baseUrl + buildRoute(endpoint.route, routeParams);
    const agent = buildAgent(options);
    // Monta headers padrões
    const defaultHeaders = {
        ...(authorization ? { Authorization: authorization } : {}),
        ...(validateMtls !== undefined ? { 'x-skip-mtls-checking': (!validateMtls).toString() } : {}),
        ...(partner_token ? { 'partner-token': partner_token } : {}),
        ...(idempotencyKey ? { 'x-idempotency-key': idempotencyKey } : {}),
    };
    const config = {
        url,
        method: endpoint.method,
        data: body,
        params,
        headers: { ...defaultHeaders, ...headers },
        ...(agent ? { httpsAgent: agent } : {}),
    };
    try {
        const response = await (0, axios_1.default)(config);
        return response.data;
    }
    catch (error) {
        if (error.response && error.response.data) {
            throw error.response.data;
        }
        throw error;
    }
}
exports.httpRequest = httpRequest;
