"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EfiSdk = void 0;
const endpoints_1 = require("./constants/endpoints");
const httpClient_1 = require("./httpClient");
const axios_1 = __importDefault(require("axios"));
const https_1 = __importDefault(require("https"));
const fs_1 = __importDefault(require("fs"));
function getApiConfig(api, sandbox) {
    const apiConfig = endpoints_1.endpoints.APIS[api];
    return {
        baseUrl: sandbox ? apiConfig.URL.SANDBOX : apiConfig.URL.PRODUCTION,
        authRoute: apiConfig.ENDPOINTS.authorize.route,
    };
}
class EfiSdk {
    constructor(options) {
        this.tokenMap = { PIX: null, DEFAULT: null };
        if (!options.client_id || !options.client_secret) {
            throw new Error('client_id e client_secret são obrigatórios');
        }
        this.options = options;
    }
    isTokenExpired(token) {
        if (!token)
            return true;
        const now = Math.floor(Date.now() / 1000);
        if (typeof token.expires_in !== 'number' || typeof token.authDate !== 'number')
            return true;
        return now > (token.authDate + token.expires_in - 60); // 60s de margem
    }
    buildAgent() {
        if (!this.options.certificate)
            return undefined;
        try {
            if (!this.options.cert_base64) {
                if (this.options.pemKey) {
                    return new https_1.default.Agent({
                        cert: fs_1.default.readFileSync(this.options.certificate),
                        key: fs_1.default.readFileSync(this.options.pemKey),
                        passphrase: '',
                    });
                }
                else {
                    return new https_1.default.Agent({
                        pfx: fs_1.default.readFileSync(this.options.certificate),
                        passphrase: '',
                    });
                }
            }
            else {
                if (this.options.pemKey) {
                    return new https_1.default.Agent({
                        cert: Buffer.from(this.options.certificate, 'base64'),
                        key: Buffer.from(this.options.pemKey, 'base64'),
                        passphrase: '',
                    });
                }
                else {
                    return new https_1.default.Agent({
                        pfx: Buffer.from(this.options.certificate, 'base64'),
                        passphrase: '',
                    });
                }
            }
        }
        catch (error) {
            throw new Error('Erro ao ler o certificado ou chave: ' + error.message);
        }
    }
    async authenticate(api) {
        const { baseUrl, authRoute } = getApiConfig(api, this.options.sandbox);
        const currentToken = this.tokenMap[api];
        if (currentToken && !this.isTokenExpired(currentToken)) {
            return currentToken.access_token;
        }
        const agent = this.buildAgent();
        const isDefault = api === 'DEFAULT';
        let authParams = {
            method: 'POST',
            url: baseUrl + authRoute,
            headers: {
                'api-sdk': 'efi-node-typescript',
            },
            data: {
                grant_type: 'client_credentials',
            },
            httpsAgent: agent,
        };
        if (isDefault) {
            authParams.auth = {
                username: this.options.client_id,
                password: this.options.client_secret,
            };
        }
        else {
            const token = Buffer.from(this.options.client_id + ':' + this.options.client_secret).toString('base64');
            authParams.headers['Authorization'] = 'Basic ' + token;
            authParams.headers['Content-Type'] = 'application/json';
        }
        const res = await (0, axios_1.default)(authParams);
        this.tokenMap[api] = {
            ...res.data,
            authDate: Math.floor(Date.now() / 1000),
        };
        return res.data.access_token;
    }
    async authorizedRequest(api, opts) {
        const { baseUrl } = getApiConfig(api, this.options.sandbox);
        const access_token = await this.authenticate(api);
        return (0, httpClient_1.httpRequest)({
            ...opts,
            baseUrl,
            authorization: `Bearer ${access_token}`,
        });
    }
    async pixCreateImmediateCharge(body, headers) {
        return this.authorizedRequest('PIX', {
            endpoint: endpoints_1.endpoints.APIS.PIX.ENDPOINTS.pixCreateImmediateCharge,
            body,
            headers,
            certificate: this.options.certificate,
            pemKey: this.options.pemKey,
            cert_base64: this.options.cert_base64,
            partner_token: this.options.partner_token,
            validateMtls: this.options.validateMtls,
            idempotencyKey: this.options.idempotencyKey,
        });
    }
    // Exemplo de método para DEFAULT (ex: listCharges)
    async listCharges(params, headers) {
        return this.authorizedRequest('DEFAULT', {
            endpoint: endpoints_1.endpoints.APIS.DEFAULT.ENDPOINTS.listCharges,
            params,
            headers,
            certificate: this.options.certificate,
            pemKey: this.options.pemKey,
            cert_base64: this.options.cert_base64,
            partner_token: this.options.partner_token,
            validateMtls: this.options.validateMtls,
            idempotencyKey: this.options.idempotencyKey,
        });
    }
}
exports.EfiSdk = EfiSdk;
